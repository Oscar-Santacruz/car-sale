"use client"

import * as React from "react"
import { Check, ChevronsUpDown } from "lucide-react"

import { cn } from "@/lib/utils"
import { Button } from "@/components/ui/button"
import {
  Command,
  CommandEmpty,
  CommandGroup,
  CommandInput,
  CommandItem,
  CommandList,
} from "@/components/ui/command"
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover"

interface ComboboxContextValue {
  value?: string
  onValueChange?: (value: string) => void
  open: boolean
  setOpen: (open: boolean) => void
}

const ComboboxContext = React.createContext<ComboboxContextValue | null>(null)

export function Combobox({
  children,
  value,
  onValueChange,
  disabled
}: {
  children: React.ReactNode
  value?: string
  onValueChange?: (value: string) => void
  disabled?: boolean
}) {
  const [open, setOpen] = React.useState(false)

  return (
    <ComboboxContext.Provider value={{ value, onValueChange, open, setOpen }}>
      <Popover open={open} onOpenChange={setOpen}>
        {children}
      </Popover>
    </ComboboxContext.Provider>
  )
}

export function ComboboxTrigger({
  className,
  children,
  asChild,
  disabled,
  ...props
}: React.ComponentPropsWithoutRef<typeof PopoverTrigger> & { disabled?: boolean }) {
  // If asChild is true, we just render the child (which should be a button-like element)
  // Otherwise we render a default Button
  if (asChild) {
    return (
      <PopoverTrigger asChild {...props}>
        {children}
      </PopoverTrigger>
    )
  }

  return (
    <PopoverTrigger asChild disabled={disabled} {...props}>
      <Button
        variant="outline"
        role="combobox"
        className={cn("w-full justify-between", className)}
      >
        {children}
        <ChevronsUpDown className="ml-2 h-4 w-4 shrink-0 opacity-50" />
      </Button>
    </PopoverTrigger>
  )
}

export function ComboboxContent({
  children,
  className,
  ...props
}: React.ComponentPropsWithoutRef<typeof PopoverContent>) {
  return (
    <PopoverContent className={cn("w-[var(--radix-popover-trigger-width)] p-0", className)} align="start" {...props}>
      <Command>
        {children}
      </Command>
    </PopoverContent>
  )
}

export function ComboboxInput({
  className,
  ...props
}: React.ComponentPropsWithoutRef<typeof CommandInput>) {
  return <CommandInput className={className} {...props} />
}

export function ComboboxList({
  children,
  className,
  ...props
}: React.ComponentPropsWithoutRef<typeof CommandList>) {
  return <CommandList className={className} {...props}>{children}</CommandList>
}

export function ComboboxEmpty({
  children,
  ...props
}: React.ComponentPropsWithoutRef<typeof CommandEmpty>) {
  return <CommandEmpty {...props}>{children}</CommandEmpty>
}

export function ComboboxGroup({
  children,
  ...props
}: React.ComponentPropsWithoutRef<typeof CommandGroup>) {
  return <CommandGroup {...props}>{children}</CommandGroup>
}

export function ComboboxItem({
  children,
  value,
  onSelect,
  className,
  ...props
}: React.ComponentPropsWithoutRef<typeof CommandItem>) {
  const context = React.useContext(ComboboxContext)

  return (
    <CommandItem
      value={value}
      onSelect={(currentValue) => {
        // Use the passed 'value' prop if available, otherwise the one generated by cmdk (currentValue)
        const val = (value || currentValue) as string
        context?.onValueChange?.(val === context.value ? "" : val)
        if (onSelect) {
          onSelect(val)
        } else {
          context?.setOpen(false)
        }
      }}
      className={className}
      {...props}
    >
      <Check
        className={cn(
          "mr-2 h-4 w-4",
          context?.value === value ? "opacity-100" : "opacity-0"
        )}
      />
      {children}
    </CommandItem>
  )
}

export function ComboboxValue({
  children,
  placeholder
}: {
  children?: React.ReactNode
  placeholder?: string
}) {
  const context = React.useContext(ComboboxContext)
  // We render children if they exist, otherwise placeholder. 
  // The 'value' from context helps decide if there is a selection, 
  // but usually the consumer passes the display text as children.
  // If the consumer uses children for display, it works.
  return (
    <span className="truncate">
      {children || placeholder || "Select..."}
    </span>
  )
}
